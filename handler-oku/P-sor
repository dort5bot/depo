
ğŸŸ§ğŸŸ§ğŸŸ§ğŸŸ§
kaynak
utils/binance/binance_a.py
(aggregator)

"""utils/binance/binance_a.py
Binance API aggregator - Ana toplayÄ±cÄ± sÄ±nÄ±f.

Bu modÃ¼l, BinancePublicAPI ve BinancePrivateAPI sÄ±nÄ±flarÄ±nÄ± birleÅŸtirerek
tÃ¼m Binance API endpoint'lerine tek bir noktadan eriÅŸim saÄŸlar.

KullanÄ±m:
    from utils.binance.binance_a import BinanceAPI
    from utils.binance.binance_request import BinanceHTTPClient
    from utils.binance.binance_circuit_breaker import CircuitBreaker

    http_client = BinanceHTTPClient(api_key="...", secret_key="...")
    cb = CircuitBreaker(...)
    binance = BinanceAPI(http_client, cb)

    # Public endpoint
    server_time = await binance.public.get_server_time()
    
    # Private endpoint
    account_info = await binance.private.get_account_info()

ğŸ”§ Ã–zellikler:
- Singleton pattern
- Async/await uyumlu
- Type hints + docstring
- Logging
- PEP8 uyumlu
"""

import logging
from typing import Optional

from .binance_request import BinanceHTTPClient
from .binance_circuit_breaker import CircuitBreaker
from .binance_public import BinancePublicAPI
from .binance_private import BinancePrivateAPI

logger = logging.getLogger(__name__)


class BinanceAPI:
    """
    Binance API aggregator sÄ±nÄ±fÄ±.

    Bu sÄ±nÄ±f, hem public hem de private Binance API'lerine eriÅŸim saÄŸlar.
    Singleton pattern kullanÄ±r.
    """

    _instance: Optional["BinanceAPI"] = None

    def __new__(cls, http_client: BinanceHTTPClient, circuit_breaker: CircuitBreaker) -> "BinanceAPI":
        """
        Singleton instance dÃ¶ndÃ¼rÃ¼r.

        Args:
            http_client: BinanceHTTPClient Ã¶rneÄŸi
            circuit_breaker: CircuitBreaker Ã¶rneÄŸi

        Returns:
            BinanceAPI singleton instance
        """
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialize(http_client, circuit_breaker)
            logger.info("âœ… BinanceAPI aggregator singleton instance created")
        return cls._instance

    def _initialize(self, http_client: BinanceHTTPClient, circuit_breaker: CircuitBreaker) -> None:
        """
        Instance'Ä± baÅŸlat.

        Args:
            http_client: BinanceHTTPClient Ã¶rneÄŸi
            circuit_breaker: CircuitBreaker Ã¶rneÄŸi
        """
        self.http = http_client
        self.circuit_breaker = circuit_breaker
        
        # Public ve private API'leri oluÅŸtur
        self.public = BinancePublicAPI(http_client, circuit_breaker)
        self.private = BinancePrivateAPI(http_client, circuit_breaker)
        
        logger.info("âœ… BinanceAPI aggregator initialized with public and private APIs")

    async def close(self) -> None:
        """
        HTTP client'Ä± kapat ve kaynaklarÄ± temizle.
        """
        if hasattr(self, 'http'):
            await self.http.close()
            logger.info("âœ… BinanceAPI HTTP client closed")

    def __del__(self) -> None:
        """
        Destructor - HTTP client'Ä± kapat.
        """
        import asyncio
        try:
            loop = asyncio.get_event_loop()
            if loop.is_running():
                loop.create_task(self.close())
            else:
                loop.run_until_complete(self.close())
        except Exception:
            pass  # Ignore errors during cleanup

    # -------------------------
    # Convenience Methods
    # -------------------------
    async def ping(self) -> bool:
        """
        Binance API'ye ping at ve baÄŸlantÄ±yÄ± test et.

        Returns:
            True if ping successful, False otherwise
        """
        try:
            result = await self.public.ping()
            return result == {}  # Binance ping returns empty dict on success
        except Exception as e:
            logger.warning(f"âŒ Ping failed: {e}")
            return False

    async def check_api_keys(self) -> bool:
        """
        API key'lerin geÃ§erli olup olmadÄ±ÄŸÄ±nÄ± kontrol et.

        Returns:
            True if API keys are valid, False otherwise
        """
        try:
            await self.private.get_account_info()
            return True
        except Exception as e:
            logger.warning(f"âŒ API key check failed: {e}")
            return False

    async def get_balance(self, asset: Optional[str] = None, futures: bool = False) -> dict:
        """
        Hesap bakiyesini getir (spot veya futures).

        Args:
            asset: Optional asset symbol (e.g., "BTC")
            futures: If True, get futures balance

        Returns:
            Balance information
        """
        if futures:
            if asset:
                # Futures iÃ§in asset bazlÄ± bakiye
                balances = await self.private.get_futures_balance()
                for balance in balances:
                    if balance.get('asset') == asset.upper():
                        return balance
                return {}
            return await self.private.get_futures_balance()
        else:
            return await self.private.get_account_balance(asset)

    async def get_symbol_info(self, symbol: str, futures: bool = False) -> Optional[dict]:
        """
        Sembol bilgilerini getir.

        Args:
            symbol: Trading pair symbol
            futures: If True, get futures symbol info

        Returns:
            Symbol information or None if not found
        """
        try:
            if futures:
                exchange_info = await self.public.get_futures_exchange_info()
            else:
                exchange_info = await self.public.get_exchange_info()
            
            for s in exchange_info.get('symbols', []):
                if s.get('symbol') == symbol.upper():
                    return s
            return None
        except Exception as e:
            logger.error(f"Error getting symbol info for {symbol}: {e}")
            return None

    async def get_all_symbols(self, futures: bool = False) -> list:
        """
        TÃ¼m sembolleri getir.

        Args:
            futures: If True, get futures symbols

        Returns:
            List of all symbols
        """
        if futures:
            return await self.public.get_all_futures_symbols()
        return await self.public.get_all_symbols()

    async def get_price(self, symbol: str, futures: bool = False) -> Optional[float]:
        """
        SembolÃ¼n mevcut fiyatÄ±nÄ± getir.

        Args:
            symbol: Trading pair symbol
            futures: If True, get futures price

        Returns:
            Current price or None if error
        """
        try:
            if futures:
                ticker = await self.public.get_futures_24hr_ticker(symbol)
                return float(ticker.get('lastPrice', 0))
            else:
                price_data = await self.public.get_symbol_price(symbol)
                return float(price_data.get('price', 0))
        except Exception as e:
            logger.error(f"Error getting price for {symbol}: {e}")
            return None

    # -------------------------
    # Order Management Convenience
    # -------------------------
    async def create_order(self, symbol: str, side: str, order_type: str, quantity: float,
                          price: Optional[float] = None, futures: bool = False, **kwargs) -> dict:
        """
        Yeni order oluÅŸtur.

        Args:
            symbol: Trading pair symbol
            side: "BUY" or "SELL"
            order_type: "LIMIT", "MARKET", etc.
            quantity: Order quantity
            price: Order price (for limit orders)
            futures: If True, create futures order
            **kwargs: Additional order parameters

        Returns:
            Order creation result
        """
        if futures:
            return await self.private.place_futures_order(
                symbol, side, order_type, quantity, price, **kwargs
            )
        else:
            return await self.private.place_order(
                symbol, side, order_type, quantity, price, **kwargs
            )

    async def cancel_order(self, symbol: str, order_id: Optional[int] = None,
                          orig_client_order_id: Optional[str] = None, futures: bool = False) -> dict:
        """
        Order iptal et.

        Args:
            symbol: Trading pair symbol
            order_id: Order ID
            orig_client_order_id: Client order ID
            futures: If True, cancel futures order

        Returns:
            Cancellation result
        """
        if futures:
            return await self.private.cancel_futures_order(
                symbol, order_id, orig_client_order_id
            )
        else:
            return await self.private.cancel_order(
                symbol, order_id, orig_client_order_id
            )

    async def get_open_orders(self, symbol: Optional[str] = None, futures: bool = False) -> list:
        """
        AÃ§Ä±k order'larÄ± getir.

        Args:
            symbol: Optional trading pair symbol
            futures: If True, get futures orders

        Returns:
            List of open orders
        """
        if futures:
            return await self.private.get_futures_open_orders(symbol)
        else:
            return await self.private.get_open_orders(symbol)

    # -------------------------
    # Position Management (Futures)
    # -------------------------
    async def get_positions(self, symbol: Optional[str] = None) -> list:
        """
        Futures pozisyonlarÄ± getir.

        Args:
            symbol: Optional trading pair symbol

        Returns:
            List of positions
        """
        positions = await self.private.get_futures_positions()
        if symbol:
            symbol_upper = symbol.upper()
            return [p for p in positions if p.get('symbol') == symbol_upper]
        return positions

    async def get_position(self, symbol: str) -> Optional[dict]:
        """
        Belirli bir sembolÃ¼n futures pozisyonunu getir.

        Args:
            symbol: Trading pair symbol

        Returns:
            Position information or None if not found
        """
        positions = await self.get_positions(symbol)
        return positions[0] if positions else None

    async def set_leverage(self, symbol: str, leverage: int) -> dict:
        """
        Futures kaldÄ±raÃ§ oranÄ±nÄ± ayarla.

        Args:
            symbol: Trading pair symbol
            leverage: Leverage value

        Returns:
            Result of leverage change
        """
        return await self.private.change_futures_leverage(symbol, leverage)

    async def set_margin_type(self, symbol: str, margin_type: str) -> dict:
        """
        Futures margin tipini ayarla.

        Args:
            symbol: Trading pair symbol
            margin_type: "ISOLATED" or "CROSSED"

        Returns:
            Result of margin type change
        """
        return await self.private.change_futures_margin_type(symbol, margin_type)

    # -------------------------
    # User Data Stream
    # -------------------------
    async def create_listen_key(self, futures: bool = False) -> str:
        """
        ListenKey oluÅŸtur.

        Args:
            futures: If True, create futures listen key

        Returns:
            Listen key
        """
        result = await self.private.create_listen_key(futures)
        return result.get('listenKey', '')

    async def keepalive_listen_key(self, listen_key: str, futures: bool = False) -> dict:
        """
        ListenKey'i yenile.

        Args:
            listen_key: Listen key to keep alive
            futures: If True, keep alive futures listen key

        Returns:
            Result of keepalive operation
        """
        return await self.private.keepalive_listen_key(listen_key, futures)

    async def close_listen_key(self, listen_key: str, futures: bool = False) -> dict:
        """
        ListenKey'i kapat.

        Args:
            listen_key: Listen key to close
            futures: If True, close futures listen key

        Returns:
            Result of close operation
        """
        return await self.private.close_listen_key(listen_key, futures)

    # -------------------------
    # Additional convenience methods
    # -------------------------
    async def get_24h_stats(self, symbol: str, futures: bool = False) -> dict:
        """
        24 saatlik istatistikleri getir.

        Args:
            symbol: Trading pair symbol
            futures: If True, get futures stats

        Returns:
            24-hour statistics
        """
        if futures:
            tickers = await self.public.get_futures_24hr_ticker(symbol)
            if isinstance(tickers, list):
                for ticker in tickers:
                    if ticker.get('symbol') == symbol.upper():
                        return ticker
                return {}
            return tickers
        else:
            return await self.public.get_all_24h_tickers(symbol)

    async def get_order_book(self, symbol: str, limit: int = 100, futures: bool = False) -> dict:
        """
        Order book'u getir.

        Args:
            symbol: Trading pair symbol
            limit: Depth limit
            futures: If True, get futures order book

        Returns:
            Order book data
        """
        if futures:
            return await self.public.get_futures_order_book(symbol, limit)
        else:
            return await self.public.get_order_book(symbol, limit)

    async def get_klines(self, symbol: str, interval: str = "1m", limit: int = 500, futures: bool = False) -> list:
        """
        Kline/candlestick verilerini getir.

        Args:
            symbol: Trading pair symbol
            interval: Kline interval
            limit: Number of klines
            futures: If True, get futures klines

        Returns:
            List of klines
        """
        if futures:
            return await self.public.get_futures_klines(symbol, interval, limit)
        else:
            return await self.public.get_klines(symbol, interval, limit)

    async def get_mark_price(self, symbol: str) -> dict:
        """
        Futures mark price'Ä± getir.

        Args:
            symbol: Trading pair symbol

        Returns:
            Mark price data
        """
        return await self.public.get_futures_mark_price(symbol)

    async def get_funding_rate_history(self, symbol: str, limit: int = 100) -> list:
        """
        Funding rate geÃ§miÅŸini getir.

        Args:
            symbol: Trading pair symbol
            limit: Number of records

        Returns:
            Funding rate history
        """
        return await self.public.get_futures_funding_rate_history(symbol, limit)

    async def get_open_interest(self, symbol: str) -> dict:
        """
        Open interest'i getir.

        Args:
            symbol: Trading pair symbol

        Returns:
            Open interest data
        """
        return await self.public.get_futures_open_interest(symbol)

    # -------------------------
    # Wallet operations
    # -------------------------
    async def get_deposit_address(self, coin: str, network: Optional[str] = None) -> dict:
        """
        Deposit adresi getir.

        Args:
            coin: Coin symbol
            network: Network name

        Returns:
            Deposit address information
        """
        return await self.private.get_deposit_address(coin, network)

    async def get_deposit_history(self, coin: Optional[str] = None, status: Optional[int] = None,
                                 start_time: Optional[int] = None, end_time: Optional[int] = None) -> list:
        """
        Deposit geÃ§miÅŸini getir.

        Args:
            coin: Coin symbol
            status: Deposit status
            start_time: Start timestamp
            end_time: End timestamp

        Returns:
            Deposit history
        """
        return await self.private.get_deposit_history(coin, status, start_time, end_time)

    async def get_withdraw_history(self, coin: Optional[str] = None, status: Optional[int] = None,
                                  start_time: Optional[int] = None, end_time: Optional[int] = None) -> list:
        """
        Withdrawal geÃ§miÅŸini getir.

        Args:
            coin: Coin symbol
            status: Withdrawal status
            start_time: Start timestamp
            end_time: End timestamp

        Returns:
            Withdrawal history
        """
        return await self.private.get_withdraw_history(coin, status, start_time, end_time)

    async def withdraw_crypto(self, coin: str, address: str, amount: float,
                             network: Optional[str] = None, address_tag: Optional[str] = None) -> dict:
        """
        Cryptocurrency withdraw et.

        Args:
            coin: Coin symbol
            address: Withdrawal address
            amount: Amount to withdraw
            network: Network name
            address_tag: Address tag

        Returns:
            Withdrawal result
        """
        return await self.private.withdraw(coin, address, amount, network, address_tag)

    # -------------------------
    # Staking operations
    # -------------------------
    async def get_staking_products(self, product: str = "STAKING", asset: Optional[str] = None) -> list:
        """
        Staking Ã¼rÃ¼nlerini getir.

        Args:
            product: Product type
            asset: Asset symbol

        Returns:
            List of staking products
        """
        return await self.private.get_staking_product_list(product, asset)

    async def stake(self, product: str, product_id: str, amount: float) -> dict:
        """
        VarlÄ±k stake et.

        Args:
            product: Product type
            product_id: Product ID
            amount: Amount to stake

        Returns:
            Staking result
        """
        return await self.private.stake_asset(product, product_id, amount)

    async def unstake(self, product: str, product_id: str, position_id: Optional[str] = None,
                     amount: Optional[float] = None) -> dict:
        """
        VarlÄ±k unstake et.

        Args:
            product: Product type
            product_id: Product ID
            position_id: Position ID
            amount: Amount to unstake

        Returns:
            Unstaking result
        """
        return await self.private.unstake_asset(product, product_id, position_id, amount)

    async def get_staking_history(self, product: str, txn_type: str, asset: Optional[str] = None,
                                 start_time: Optional[int] = None, end_time: Optional[int] = None) -> list:
        """
        Staking geÃ§miÅŸini getir.

        Args:
            product: Product type
            txn_type: Transaction type
            asset: Asset symbol
            start_time: Start timestamp
            end_time: End timestamp

        Returns:
            Staking history
        """
        return await self.private.get_staking_history(product, txn_type, asset, start_time, end_time)

    # -------------------------
    # Savings operations
    # -------------------------
    async def get_savings_products(self, product_type: str = "ACTIVITY", asset: Optional[str] = None) -> list:
        """
        Savings Ã¼rÃ¼nlerini getir.

        Args:
            product_type: Product type
            asset: Asset symbol

        Returns:
            List of savings products
        """
        return await self.private.get_savings_product_list(product_type, asset)

    async def purchase_savings(self, product_id: str, amount: float) -> dict:
        """
        Savings Ã¼rÃ¼nÃ¼ satÄ±n al.

        Args:
            product_id: Product ID
            amount: Amount to purchase

        Returns:
            Purchase result
        """
        return await self.private.purchase_savings_product(product_id, amount)

    async def get_savings_balance(self, asset: Optional[str] = None) -> dict:
        """
        Savings bakiyesini getir.

        Args:
            asset: Asset symbol

   

ğŸŸ§ğŸŸ§ğŸŸ§ğŸŸ§
config.py

"""bot/config.py - Aiogram 3.x uyumlu optimal config yÃ¶netimi

Binance ve Aiogram iÃ§in yapÄ±landÄ±rma sÄ±nÄ±fÄ±. Default deÄŸerler ile gelir,
.env dosyasÄ±ndaki deÄŸerlerle override edilir.
"""

import os
import logging
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from dotenv import load_dotenv

# Environment variables'Ä± yÃ¼kle
load_dotenv()

# Logging yapÄ±landÄ±rmasÄ±
logger = logging.getLogger(__name__)
logger.setLevel(logging.getLevelName(os.getenv("LOG_LEVEL", "INFO")))

# Global cache instance
_CONFIG_INSTANCE: Optional["BotConfig"] = None


@dataclass
class BotConfig:
    """Aiogram 3.x uyumlu bot yapÄ±landÄ±rma sÄ±nÄ±fÄ±."""
    
    # ========================
    # ğŸ¤– TELEGRAM BOT SETTINGS
    # ========================
    TELEGRAM_TOKEN: str = field(default_factory=lambda: os.getenv("TELEGRAM_TOKEN", ""))
    NGROK_URL: str = field(default_factory=lambda: os.getenv("NGROK_URL", "https://2fce5af7336f.ngrok-free.app"))
    
    DEFAULT_LOCALE: str = field(default_factory=lambda: os.getenv("DEFAULT_LOCALE", "en"))
    ADMIN_IDS: List[int] = field(default_factory=lambda: [
        int(x.strip()) for x in os.getenv("ADMIN_IDS", "").split(",") if x.strip().isdigit()
    ])
    
    # Webhook settings
    USE_WEBHOOK: bool = field(default_factory=lambda: os.getenv("USE_WEBHOOK", "false").lower() == "true")
    WEBHOOK_HOST: str = field(default_factory=lambda: os.getenv("WEBHOOK_HOST", ""))
    WEBHOOK_SECRET: str = field(default_factory=lambda: os.getenv("WEBHOOK_SECRET", ""))
    WEBAPP_HOST: str = field(default_factory=lambda: os.getenv("WEBAPP_HOST", "0.0.0.0"))
    WEBAPP_PORT: int = field(default_factory=lambda: int(os.getenv("PORT", "3000")))  # Render PORT variable
    
    # Aiogram specific settings
    AIOGRAM_REDIS_HOST: str = field(default_factory=lambda: os.getenv("AIOGRAM_REDIS_HOST", "localhost"))
    AIOGRAM_REDIS_PORT: int = field(default_factory=lambda: int(os.getenv("AIOGRAM_REDIS_PORT", "6379")))
    AIOGRAM_REDIS_DB: int = field(default_factory=lambda: int(os.getenv("AIOGRAM_REDIS_DB", "0")))
    
    # FSM storage settings
    USE_REDIS_FSM: bool = field(default_factory=lambda: os.getenv("USE_REDIS_FSM", "true").lower() == "true")
    FSM_STORAGE_TTL: int = field(default_factory=lambda: int(os.getenv("FSM_STORAGE_TTL", "3600")))
    
    # ========================
    # ğŸ” BINANCE API SETTINGS
    # ========================
    BINANCE_API_KEY: str = field(default_factory=lambda: os.getenv("BINANCE_API_KEY", ""))
    BINANCE_API_SECRET: str = field(default_factory=lambda: os.getenv("BINANCE_API_SECRET", ""))
    BINANCE_BASE_URL: str = field(default_factory=lambda: os.getenv("BINANCE_BASE_URL", "https://api.binance.com"))
    BINANCE_FAPI_URL: str = field(default_factory=lambda: os.getenv("BINANCE_FAPI_URL", "https://fapi.binance.com"))
    BINANCE_WS_URL: str = field(default_factory=lambda: os.getenv("BINANCE_WS_URL", "wss://stream.binance.com:9443/ws"))

    # ========================
    # âš™ï¸ TECHNICAL SETTINGS
    # ========================
    DEBUG: bool = field(default_factory=lambda: os.getenv("DEBUG", "false").lower() == "true")
    LOG_LEVEL: str = field(default_factory=lambda: os.getenv("LOG_LEVEL", "INFO"))
    
    # Rate limiting
    REQUEST_TIMEOUT: int = field(default_factory=lambda: int(os.getenv("REQUEST_TIMEOUT", "30")))
    MAX_REQUESTS_PER_MINUTE: int = field(default_factory=lambda: int(os.getenv("MAX_REQUESTS_PER_MINUTE", "1200")))
    
    # Database settings
    DATABASE_URL: str = field(default_factory=lambda: os.getenv("DATABASE_URL", ""))
    USE_DATABASE: bool = field(default_factory=lambda: os.getenv("USE_DATABASE", "false").lower() == "true")
    
    # Cache settings
    CACHE_TTL: int = field(default_factory=lambda: int(os.getenv("CACHE_TTL", "300")))
    MAX_CACHE_SIZE: int = field(default_factory=lambda: int(os.getenv("MAX_CACHE_SIZE", "1000")))

    # ========================
    # ğŸ“Š TRADING SETTINGS
    # ========================
    SCAN_SYMBOLS: List[str] = field(default_factory=lambda: [
        symbol.strip() for symbol in os.getenv(
            "SCAN_SYMBOLS", 
            "BTCUSDT,ETHUSDT,BNBUSDT,SOLUSDT,TRXUSDT,CAKEUSDT,SUIUSDT,PEPEUSDT,ARPAUSDT,TURBOUSDT"
        ).split(",") if symbol.strip()
    ])
    
    ENABLE_TRADING: bool = field(default_factory=lambda: os.getenv("ENABLE_TRADING", "false").lower() == "true")
    TRADING_STRATEGY: str = field(default_factory=lambda: os.getenv("TRADING_STRATEGY", "conservative"))
    MAX_LEVERAGE: int = field(default_factory=lambda: int(os.getenv("MAX_LEVERAGE", "3")))
    
    # Alert settings
    ALERT_PRICE_CHANGE_PERCENT: float = field(default_factory=lambda: float(os.getenv("ALERT_PRICE_CHANGE_PERCENT", "5.0")))
    ENABLE_PRICE_ALERTS: bool = field(default_factory=lambda: os.getenv("ENABLE_PRICE_ALERTS", "true").lower() == "true")
    ALERT_COOLDOWN: int = field(default_factory=lambda: int(os.getenv("ALERT_COOLDOWN", "300")))

    # ========================
    # ğŸ› ï¸ METHODS & PROPERTIES
    # ========================

    @property
    def WEBHOOK_PATH(self) -> str:
        """Webhook path'i dinamik olarak oluÅŸturur."""
        if not self.TELEGRAM_TOKEN:
            return "/webhook/default"
        return f"/webhook/{self.TELEGRAM_TOKEN}"

    @property
    def WEBHOOK_URL(self) -> str:
        """Tam webhook URL'ini oluÅŸturur."""
        return f"{self.NGROK_URL}{self.WEBHOOK_PATH}"

    @classmethod
    def load(cls) -> "BotConfig":
        """Environment'dan config yÃ¼kler."""
        return cls()

    def validate(self) -> bool:
        """Config deÄŸerlerini doÄŸrular."""
        errors = []
        
        # Telegram bot validation
        if not self.TELEGRAM_TOKEN:
            errors.append("âŒ TELEGRAM_TOKEN gereklidir")
        
        # Webhook validation (eÄŸer webhook kullanÄ±lÄ±yorsa)
        if self.USE_WEBHOOK:
            if not self.WEBHOOK_HOST:
                errors.append("âŒ WEBHOOK_HOST gereklidir (USE_WEBHOOK=true)")
            if not self.WEBHOOK_PATH:
                errors.append("âŒ WEBHOOK_PATH gereklidir (USE_WEBHOOK=true)")
        
        # Binance validation (eÄŸer trading enabled ise)
        if self.ENABLE_TRADING:
            if not self.BINANCE_API_KEY:
                errors.append("âŒ BINANCE_API_KEY gereklidir (trading enabled)")
            if not self.BINANCE_API_SECRET:
                errors.append("âŒ BINANCE_API_SECRET gereklidir (trading enabled)")
        
        if errors:
            raise ValueError("\n".join(errors))
        
        return True

    def is_admin(self, user_id: int) -> bool:
        """KullanÄ±cÄ±nÄ±n admin olup olmadÄ±ÄŸÄ±nÄ± kontrol eder."""
        return user_id in self.ADMIN_IDS

    def to_dict(self) -> Dict[str, Any]:
        """Config'i dict olarak dÃ¶ndÃ¼rÃ¼r (debug/log amaÃ§lÄ±)."""
        sensitive_fields = {"TELEGRAM_TOKEN", "BINANCE_API_KEY", "BINANCE_API_SECRET", "WEBHOOK_SECRET"}
        result = {}
        
        for field_name in self.__dataclass_fields__:
            value = getattr(self, field_name)
            if field_name in sensitive_fields and value:
                result[field_name] = "***HIDDEN***"
            else:
                result[field_name] = value
        
        # Property'leri de ekle
        result["WEBHOOK_PATH"] = self.WEBHOOK_PATH
        result["WEBHOOK_URL"] = self.WEBHOOK_URL
        
        return result


async def get_config() -> BotConfig:
    """Global config instance'Ä±nÄ± dÃ¶ndÃ¼rÃ¼r.
    
    Aiogram 3.x ile uyumlu async singleton pattern.
    """
    global _CONFIG_INSTANCE
    if _CONFIG_INSTANCE is None:
        _CONFIG_INSTANCE = BotConfig.load()
        _CONFIG_INSTANCE.validate()
        logger.info("âœ… Bot config yÃ¼klendi ve doÄŸrulandÄ±")
        logger.debug(f"Config: {_CONFIG_INSTANCE.to_dict()}")
    return _CONFIG_INSTANCE


# Sync fonksiyonlar global instance'dan Ã§ekiyor
def get_telegram_token() -> str:
    """Aiogram iÃ§in Telegram bot token'Ä±nÄ± dÃ¶ndÃ¼rÃ¼r."""
    if _CONFIG_INSTANCE is None:
        raise RuntimeError("Config henÃ¼z yÃ¼klenmemiÅŸ. LÃ¼tfen Ã¶nce get_config() Ã§aÄŸÄ±rÄ±n.")
    return _CONFIG_INSTANCE.TELEGRAM_TOKEN


def get_admins() -> List[int]:
    """Admin kullanÄ±cÄ± ID'lerini dÃ¶ndÃ¼rÃ¼r."""
    if _CONFIG_INSTANCE is None:
        raise RuntimeError("Config henÃ¼z yÃ¼klenmemiÅŸ. LÃ¼tfen Ã¶nce get_config() Ã§aÄŸÄ±rÄ±n.")
    return _CONFIG_INSTANCE.ADMIN_IDS


def get_webhook_config() -> Dict[str, Any]:
    """Webhook konfigÃ¼rasyonu dÃ¶ndÃ¼rÃ¼r."""
    if _CONFIG_INSTANCE is None:
        raise RuntimeError("Config henÃ¼z yÃ¼klenmemiÅŸ. LÃ¼tfen Ã¶nce get_config() Ã§aÄŸÄ±rÄ±n.")
    
    config = _CONFIG_INSTANCE
    return {
        "path": config.WEBHOOK_PATH,
        "url": config.WEBHOOK_URL,
        "secret_token": config.WEBHOOK_SECRET,
        "host": config.WEBAPP_HOST,
        "port": config.WEBAPP_PORT,
    }


# Redis configuration for Aiogram
def get_redis_config() -> Dict[str, Any]:
    """Aiogram iÃ§in Redis konfigÃ¼rasyonu dÃ¶ndÃ¼rÃ¼r."""
    if _CONFIG_INSTANCE is None:
        raise RuntimeError("Config henÃ¼z yÃ¼klenmemiÅŸ. LÃ¼tfen Ã¶nce get_config() Ã§aÄŸÄ±rÄ±n.")
    
    config = _CONFIG_INSTANCE
    return {
        "host": config.AIOGRAM_REDIS_HOST,
        "port": config.AIOGRAM_REDIS_PORT,
        "db": config.AIOGRAM_REDIS_DB,

    }

ğŸŸ§ğŸŸ§ğŸŸ§ğŸŸ§
handlers/p_handler.py
Binance datasÄ±nda kÃ¼Ã§Ã¼k/bÃ¼yÃ¼k fark olsa da eÅŸleÅŸir.
handler_loader.py uyumlu

Bu handler, Binance API'sini kullanarak coin verilerini Ã§ekecek ve aiogram 3.x Router pattern'ine uygun ÅŸekilde Ã§alÄ±ÅŸacak
async/await pattern'ine uygun + aiogram 3.x e uygun + Router pattern yapÄ±da +  PEP8 + type hints + docstring + async yapÄ± + singleton + logging olacak yapÄ±da
Mevcut yorum bloklarÄ± (Ã¶r: # Rate limiting - HTTP) ekle
Aiogram 3.x Architecture

komutlar 
/p â†’CONFIG.SCAN_SYMBOLS default(filtre ekler btc ile btcusdt sonuÃ§ verir)
/Pn â†’ hacimli ilk n coin.  default 20 tane (Ã¶rnek /p30 /p40 ... destekler)
/Pd â†’ dÃ¼ÅŸenler coinler. default 20 tane
/Pd 30 â†’ dÃ¼ÅŸenler 30 tane
/P coin1 coin2... â†’ manuel seÃ§ili coinler.


Ã¶rnek:
/p

ğŸ“ˆ SCAN_SYMBOLS (Hacme GÃ¶re)
âš¡Coin | DeÄŸiÅŸim | Hacim | Fiyat
1. ETH: 0.23% | $888.8M | 4308.17
2. BTC: 0.37% | $657.1M | 111353.1
3. TRX: 0.21% | $340.8M | 0.3312
4. SOL: 0.70% | $268.1M | 203.75
...

/p22

ğŸ“ˆ En Ã‡ok YÃ¼kselen 22 Coin
âš¡Coin | DeÄŸiÅŸim | Hacim | Fiyat
1. OPEN: 656.60% | $224.8M | 1.5132
2. CREAM: 65.35% | $0.3M | 2.1
3. PNT: 45.23% | $0.3M | 0.035
4. SOMI: 44.54% | $489.4M | 1.6372
5. WLD: 42.98% | $469.9M | 1.497
...

/pd
ğŸ“ˆ DÃ¼ÅŸÃ¼ÅŸ Trendindeki Coinler
âš¡Coin | DeÄŸiÅŸim | Hacim | Fiyat
1. BETA: -64.00% | $0.3M | 0.00036
2. VIB: -63.26% | $0.4M | 0.00223
3. WTC: -56.54% | $0.5M | 0.0103
...


/p eth bnb sol

ğŸ“ˆ SeÃ§ili Coinler
âš¡Coin | DeÄŸiÅŸim | Hacim | Fiyat
1. BNB: 1.45% | $107.2M | 873.7
2. SOL: 0.73% | $269.2M | 203.78
3. ETH: 0.23% | $889.4M | 4307.04
